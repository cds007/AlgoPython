"""
演示类和对象的关系，即面向对象的编程套路（思想）
"""

# 设计一个闹钟类


class Clock:
    id = 22       # 序列化
    price = 32    # 价格
    # 这里的id和price其实应该是公共的属性，类属性
    aa = None

    def ring(self):
        import winsound
        winsound.Beep(2000, 3000)


# 构建2个闹钟对象并让其工作
clock1 = Clock()
clock1.id = "003032"  # 下面这两个是额外创建出来的属性，实际上，哪怕类中没有定义，实例也可以自己创建属性
clock1.price = 19.99
clock1.aa = 32.22
print(clock1.aa)  # 实例重写后的类属性
print(Clock.aa)  # 原本定义的类属性
Clock.aa = 322
print(Clock.aa)  # 类属性修改后的值
print(f"类中price是{Clock.price}，id是{Clock.id}")
print(f"闹钟ID：{clock1.id}，价格：{clock1.price}")
# clock1.ring()

clock2 = Clock()
clock2.id = "003033"
clock2.price = 21.99
print(clock2.aa)
print(f"闹钟ID：{clock2.id}，价格：{clock2.price}")
# clock2.ring()
"""
# 这个会报错，因为clock2没有aa这个属性 这里类属性和实例属性很模糊啊，
不过看来目前了解的规则是，如果类中定义属性，那么类和实例都可以使用，如果是实例中定义属性，那么类是不能使用的。
如果类属性没有被实例重写，那么实例调用的值是类属性的值，否则是实例的值，但是类属性调用值不会变。
（这里我的疑惑是按理来说类属性只有类改变了才能被修改吧，为什么实例修改了，它的值就专属于这个实例了呢，
 有没有一种可能是这个实例又创建了一个专属于自己的实例属性，这个实例属性只属于自身，不属于类也不属于其他属性，
 这样子的话，每个实例都可以创建自己的属性，想到这我觉得有点奇葩了，这规则限制的也太少了吧）
"""
"""
我新的一个思考是这样的，就是类其实也可以当做一个对象，用类.方法，其实也是一种对象.方法的调用方式；
这样其实就不矛盾了，一个实例修改了自身的属性值，对类本身来说，属性值是没变的，因为类也可以当作一个实例对象，但是特殊的是类属性改了，实例对象没改，
那么实例对象的属性也会变化的。
"""
